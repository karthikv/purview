"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pingServer = exports.connectWebSocket = exports.dispatchPurviewEvent = void 0;
const helpers_1 = require("./helpers");
const morph_1 = require("./morph");
const MAX_RETRIES = 7;
const RETRY_FACTOR = 1.5;
const INITIAL_WAIT_TIME = 250;
const STYLE_TAG_ERROR = `Purview: expected element with ID ${helpers_1.STYLE_TAG_ID} to be a style tag generated by purview`;
exports.dispatchPurviewEvent = (event) => {
    window.dispatchEvent(new CustomEvent("purview", {
        detail: event,
    }));
};
function connectWebSocket(location) {
    // For more context, see comment in src/browser.ts where we wait for the DOM to load.
    if (document.readyState === "loading") {
        throw new Error("Purview: connectWebSocket() should only be called after the DOM has loaded.");
    }
    const { protocol, host, pathname, search } = location;
    let wsProtocol;
    if (protocol === "https:") {
        wsProtocol = "wss:";
    }
    else if (protocol === "http:") {
        wsProtocol = "ws:";
    }
    else {
        throw new Error(`Invalid protocol ${protocol}`);
    }
    const url = `${wsProtocol}//${host}${pathname}${search}`;
    const state = {
        url,
        ws: new WebSocket(url),
        seenEventNames: new Set(),
        numRetries: 0,
        waitTime: INITIAL_WAIT_TIME,
    };
    addWebSocketHandlers(state, location);
    return state.ws;
}
exports.connectWebSocket = connectWebSocket;
function addWebSocketHandlers(state, location) {
    const ws = state.ws;
    const rawStyleElem = document.getElementById(helpers_1.STYLE_TAG_ID);
    let styleElem;
    if (rawStyleElem) {
        if (rawStyleElem instanceof HTMLStyleElement) {
            styleElem = rawStyleElem;
        }
        else {
            throw new Error(STYLE_TAG_ERROR);
        }
    }
    let interval = null;
    ws.addEventListener("open", () => {
        var _a;
        exports.dispatchPurviewEvent({ type: "websocket:open" });
        const rootElems = Array.from(document.querySelectorAll("[data-root]"));
        const rootIDs = rootElems.map(elem => {
            return elem.getAttribute("data-component-id");
        });
        if (rootElems.length === 0) {
            throw new Error("Purview: no root elements found.");
        }
        let cssStateID;
        if (styleElem) {
            cssStateID = (_a = styleElem.getAttribute("data-css-state-id")) !== null && _a !== void 0 ? _a : undefined;
        }
        rootElems.forEach(morph_1.initMorph);
        sendMessage(ws, { type: "connect", rootIDs, cssStateID });
        interval = setInterval(() => pingServer(ws, helpers_1.WS_PONG_TIMEOUT), helpers_1.WS_PING_INTERVAL);
    });
    ws.addEventListener("message", messageEvent => {
        if (messageEvent.data === "pong") {
            return;
        }
        const message = helpers_1.tryParseJSON(messageEvent.data);
        switch (message.type) {
            case "update":
                addEventHandlers(state, state.seenEventNames, message.newEventNames);
                const selector = `[data-component-id="${message.componentID}"]`;
                const elem = document.querySelector(selector);
                // Perform CSS updates before morphing so there's no FOUC.
                const { cssUpdates } = message;
                if (cssUpdates) {
                    if (!styleElem) {
                        throw new Error("Purview: could not find style element.");
                    }
                    updateCSS(state, styleElem, cssUpdates);
                }
                if (elem) {
                    morph_1.morph(elem, message.pNode);
                }
                state.numRetries = 0;
                state.waitTime = INITIAL_WAIT_TIME;
                break;
        }
    });
    ws.addEventListener("error", (error) => {
        exports.dispatchPurviewEvent({
            type: "websocket:error",
            data: { event: error },
        });
    });
    ws.addEventListener("close", () => {
        if (interval) {
            clearInterval(interval);
            interval = null;
        }
        exports.dispatchPurviewEvent({
            type: "websocket:close",
            data: { retries: state.numRetries },
        });
        if (state.numRetries === MAX_RETRIES) {
            location.reload();
        }
        else {
            if (process.env.NODE_ENV !== "test") {
                setTimeout(() => {
                    state.ws = new WebSocket(state.url);
                    addWebSocketHandlers(state, location);
                }, state.waitTime);
            }
            state.numRetries += 1;
            state.waitTime *= RETRY_FACTOR;
        }
    });
}
// At any given time, there should only be one active WebSocket, and hence one
// active termination timer, but we still use a WeakMap here for a few reasons:
//
// - We can keep this code analogous to pingClients() in purview.ts.
// - Reconnects are easy: they will introduce a new WebSocket object, which will
//   have a new timer in the map.
// - We don't need to worry about clean up.
const terminationTimers = new WeakMap();
// If the server doesn't respond with a pong in the timeout (given in
// milliseconds), forcibly terminate the connection.
function pingServer(ws, timeout) {
    if (!terminationTimers.has(ws)) {
        // First time we're processing this websocket; listen for pongs to clear
        // the termination timer.
        ws.addEventListener("message", messageEvent => {
            if (messageEvent.data === "pong") {
                const timer = terminationTimers.get(ws);
                if (timer) {
                    clearTimeout(timer);
                }
                // N.B. We want to maintain an association in the WeakMap so that we
                // don't add another pong handler.
                terminationTimers.set(ws, null);
            }
        });
    }
    // If no termination timer is set, either because one has never been set, or
    // because the last was cleared from a pong, set one.
    if (!terminationTimers.get(ws)) {
        terminationTimers.set(ws, setTimeout(() => ws.close(), timeout));
    }
    // Ask the server to send us a pong.
    ws.send("ping");
}
exports.pingServer = pingServer;
function addEventHandlers(state, seenEventNames, newEventNames) {
    let added = false;
    newEventNames.forEach(name => {
        if (!seenEventNames.has(name)) {
            handleEvent(state, name, false);
            handleEvent(state, name, true);
            seenEventNames.add(name);
            added = true;
        }
    });
    if (added) {
        sendMessage(state.ws, {
            type: "seenEventNames",
            seenEventNames: Array.from(seenEventNames),
        });
    }
}
function handleEvent(state, eventName, useCapture) {
    const attr = useCapture ? `data-${eventName}-capture` : `data-${eventName}`;
    window.addEventListener(eventName, event => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
            return;
        }
        let triggerElem = target.closest(`[${attr}]`);
        if (triggerElem && eventName === "submit") {
            event.preventDefault();
        }
        while (triggerElem) {
            const rootID = triggerElem
                .closest("[data-root]")
                .getAttribute("data-component-id");
            const componentID = triggerElem
                .closest("[data-component-id]")
                .getAttribute("data-component-id");
            const message = {
                type: "event",
                rootID,
                componentID,
                eventID: triggerElem.getAttribute(attr),
            };
            switch (eventName) {
                case "input":
                case "change":
                    message.event = {
                        name: target.name || "",
                        value: inputValue(target),
                    };
                    // The debouncing in maybeSetValue() is not foolproof. Say the user
                    // types a key during the debounce interval. It's possible for the
                    // server to send down a controlled value after the debounced
                    // callback has been run. Then the old value will be set, and if the
                    // user types anything further, his/her initial key press will be
                    // overidden and hence not take effect.
                    //
                    // To avoid this, each time the user types a key, we stop the
                    // debounced callback from running. We expect the server to send
                    // a new controlled value in response to this event, so we'll
                    // receive that value shortly and set it appropriately.
                    morph_1.clearSetValueTimer(target);
                    break;
                case "keydown":
                case "keypress":
                case "keyup":
                    message.event = {
                        name: target.name || "",
                        key: event.key,
                    };
                    break;
                case "submit":
                    const elems = target.querySelectorAll("input, select, textarea, button");
                    const fields = {};
                    Array.from(elems).forEach(elem => {
                        if (!elem.name ||
                            elem.disabled ||
                            (elem.type === "radio" && !elem.checked)) {
                            return;
                        }
                        fields[elem.name] = inputValue(elem);
                    });
                    message.event = { fields };
                    break;
            }
            sendMessage(state.ws, message);
            triggerElem = triggerElem.parentElement;
            if (triggerElem) {
                triggerElem = triggerElem.closest(`[${attr}]`);
            }
        }
    }, useCapture);
}
function inputValue(elem) {
    if (helpers_1.isSelect(elem) && elem.multiple) {
        return Array.from(elem.options)
            .filter(option => option.selected)
            .map(option => option.value);
    }
    else if (helpers_1.isInput(elem) && elem.type === "checkbox") {
        return elem.checked;
    }
    else if (helpers_1.isInput(elem) && elem.type === "number") {
        return Number(elem.value);
    }
    else {
        return elem.value;
    }
}
function updateCSS(state, styleElem, cssUpdates) {
    const sheet = styleElem.sheet;
    if (!sheet) {
        throw new Error("Purview: could not get sheet from style tag");
    }
    if (cssUpdates.nextRuleIndex > sheet.cssRules.length) {
        throw new Error("Purview: CSS rules are inconsistent (nextRuleIndex exceeds sheet.cssRules.length)");
    }
    let newCSSRules = cssUpdates.newCSSRules;
    if (sheet.cssRules.length > cssUpdates.nextRuleIndex) {
        newCSSRules = newCSSRules.slice(sheet.cssRules.length - cssUpdates.nextRuleIndex);
    }
    for (const rule of newCSSRules) {
        sheet.insertRule(rule, sheet.cssRules.length);
    }
    if (cssUpdates.nextRuleIndex + cssUpdates.newCSSRules.length !==
        sheet.cssRules.length) {
        throw new Error("Purview: CSS rules are inconsistent (lengths don't match)");
    }
    sendMessage(state.ws, {
        type: "nextRuleIndex",
        nextRuleIndex: sheet.cssRules.length,
    });
}
function sendMessage(ws, message) {
    if (ws.readyState === 1) {
        ws.send(JSON.stringify(message));
    }
}
//# sourceMappingURL=client.js.map